app: module = APP

//probably implement generic classes/structs soon
gwrap: fn::<T> = {
	Node: struct = {
		data: T,
		next: (^Node)?
	}
	LinkedList: struct = {
		first: (^Node)?,
		new: fn -> This = return This{ .first = null };
		append: fn (&mut this, value: T) = {
			if |val| (this.first) {
				last: mut ^Node = val;
				//implement options as truthy values and break
				should_loop: mut = true;
				while (should_loop) {
					if |nxt| (last.next) last = nxt;
					else should_loop = false;
				}
				last.next = gcnew Node{ .data = value, .next = null };
			} else {
				this.first = gcnew Node{ .data = value, .next = null };
			}
		}
		//temporary crutch
		print_all: fn (&this) = {
			if |val| (this.first) {
				app::func(&"${val.data}");
				last: mut ^Node = val;
				should_loop: mut = true;
				while (should_loop) {
					if |nxt| (last.next) {
						last = nxt;
						app::func(&"${last.data}");
					} else should_loop = false;
				}
			}
		}
	}
	LinkedListIterator: struct:& impl core::Iterator::<&T> = {
		curr: (^Node)?,
		impl core::Iterator::<&T>
		{
			next: fn (&mut this) -> (&T)? = {
				if |node| (this.curr) {
					this.curr = node.next;
					return &node.data;
				}
				else return null;
			}
		}
	}
}
gwrap_other: fn::<T: impl core::Iterator::<O>, O> = {
	EnumerateIter: struct:& impl core::Iterator::<(u64, O)> = {
		actual_iter: T,
		idx: u64,
		impl core::Iterator::<(u64, O)> {
			next: fn (&mut this) -> (u64, O)? = {
				if |nxt| (this.actual_iter.core::Iterator::<O>::next()) {
					this.idx = this.idx + 1;
					return (this.idx, nxt);
				}
				else return null;
			}
		}
	}
}
gwrap_third: fn::<A: impl core::Iterator::<O>, B: impl core::Iterator::<O>, O> = {
	ChainIter: struct:&	impl core::Iterator::<O> = 
{
	first_iter: A,
	second_iter: B,
	impl core::Iterator::<O> {
		next: fn (&mut this) -> O? = {
			if |nxt| (this.first_iter.core::Iterator::<O>::next()) return nxt;
			else return this.second_iter.core::Iterator::<O>::next();
		}
	}		
}
}
iter: fn::<T> (list: &gwrap::<T>::LinkedList) -> gwrap::<T>::LinkedListIterator
	= return gwrap::<T>::LinkedListIterator { .curr = list.first };

enumerate: fn::<T: impl core::Iterator::<O>, O> (iter: T) ->
	gwrap_other::<T, O>::EnumerateIter = 
	return gwrap_other::<T, O>::EnumerateIter{.actual_iter = iter, .idx = 0};

chain: fn::<A: impl core::Iterator::<O>, B: impl core::Iterator::<O>, O> 
	(first: A, snd: B) -> gwrap_third::<A, B, O>::ChainIter =
	return gwrap_third::<A, B, O>::ChainIter{.first_iter = first, .second_iter = snd};
main: fn = {
	a: mut = gwrap::<str>::LinkedList::new();
	a.append("Hello");
	a.append("World");
	a.append("Stuff");
	a.append("Others");
	b: mut = gwrap::<str>::LinkedList::new();
	b.append("Second List");
	b.append("Second List Again");
	for (lol in a.iter().chain(b.iter()).enumerate()) {
		app::func(&"${lol.0}: ${*lol.1}");
	}
}
