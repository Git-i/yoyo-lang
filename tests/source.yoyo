app: module = APP

Vector: struct impl IToStr, IToStrShort = {
    x: f32,
    y: f32,
    new: fn (x: f32, y: f32) -> Vector = return Vector{.x = x, .y = y};
    impl IToStr {
        to_str: fn (&this) -> str = {
            return "Vector: ${this.x}, ${this.y}";
        }
    }
    impl IToStrShort {
        to_str: fn (&this) -> str = {
            return "Vector";
        }
    }
}

OtherType: struct impl IToStr = {
    value: f32,
    impl IToStr {
        to_str: fn (&this) -> str = {
            return "Other Object: ${this.value}";
        }
    }
}


IToStr: interface = {
    to_str: fn (&this) -> str;
}
IToStrShort: interface = {
    to_str: fn (&this) -> str;
}
//IToStr: interface = to_str: fn (&this) -> str;

print_custom_type: fn (obj: IToStr:&) = {
    app::func(&obj.to_str());
}

return_itfs: fn -> [IToStr:^; 2] = return [
        (gcnew Vector::new(10, 20)) as IToStr:^,
        (gcnew OtherType{ .value = 100.0 }) as IToStr:^
    ];

takes_foo: fn -> f64 = {
    intfs := return_itfs();
    print_custom_type(*intfs[0]);
    print_custom_type(*intfs[1]);
    return 10.0;
} 
